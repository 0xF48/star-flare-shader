{"version":3,"sources":["webpack:///webpack/bootstrap f1a2277db856c9620837","webpack:///./node_modules/shader-box/shader-box.js","webpack:///./source/main.coffee","webpack:///./source/flare.glsl"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,cAAc;AACxE,6FAA6F,YAAY,EAAE;AAC3G,gGAAgG,eAAe,EAAE;AACjH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC,8BAA8B;AACrE,0CAA0C,iCAAiC;AAC3E,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA,gDAAgD,2BAA2B,sBAAsB,uBAAuB,oBAAoB,eAAe,kEAAkE,qBAAqB,GAAG;;AAErP,OAAO;AACP;AACA,CAAC,E;;;;;;ACjWD;;AAAA,EAAC,GAAD,EAAK,MAAL,IAAe,oBAAQ,CAAR,CAAf;;AAKA,MAAM,CAAC,GAAP,GAAa,IAAI,GAAJ,CACZ;EAAA,MAAM,CAAC,CAAD,EAAG,CAAH,CAAN;EACA,QAAQ,MAAM,CAAC,MADf;EAEA,QAAQ,IAFR;EAGA,SACC;IAAA,WAAW,KAAX;IACA,OAAO;EADP;AAJD,CADY;;AASb,QAAQ,IAAI,MAAJ,CACP;EAAA,MAAM,oBAAQ,CAAR,CAAuB,CAAC,OAA9B;EACA,UACC;IAAA,OACC;MAAA,MAAK,IAAL;MACA,KAAI;IADJ;EADD;AAFD,CADO;;AAQR,GAAG,CAAC,GAAJ,CAAQ,KAAR;;AAGA,OAAO,SAAC,CAAD;EACN,sBAAsB,IAAtB;EACA,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,GAArB,GAA2B,IAAE;SAC7B,GACC,CAAC,KADF,EAEC,CAAC,IAFF,CAEO,KAFP;AAHM;;AAQP,KAAK,CAAL;;;;;;;;;ACjCA,sFAAsC,sBAAsB,oBAAoB,4FAA4F,6EAA6E,GAAG,+BAA+B,0BAA0B,0BAA0B,iEAAiE,2CAA2C,2CAA2C,2CAA2C,wCAAwC,4GAA4G,GAAG,qGAAqG,mCAAmC,yGAAyG,GAAG,6DAA6D,qBAAqB,+EAA+E,uBAAuB,6EAA6E,sFAAsF,2GAA2G,kEAAkE,qDAAqD,yBAAyB,eAAe,GAAG,iKAAiK,6CAA6C,oBAAoB,qBAAqB,8BAA8B,wEAAwE,oCAAoC,2BAA2B,qBAAqB,4EAA4E,2CAA2C,uDAAuD,OAAO,uBAAuB,oBAAoB,OAAO,KAAK,uCAAuC,OAAO,4FAA4F,GAAG,C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f1a2277db856c9620837","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ShaderBox\"] = factory();\n\telse\n\t\troot[\"ShaderBox\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box\", function() { return Box; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shader\", function() { return Shader; });\nvar default_vertex_shader;\n\ndefault_vertex_shader = __webpack_require__(1)();\n\nvar Box = class Box {\n  constructor(opt) {\n    var j, k, ref, ref1, x, y;\n    this.setViewport = this.setViewport.bind(this);\n    this.canvas = opt.canvas;\n    this.grid = opt.grid || [1, 1];\n    this.shaders = [];\n    this.pos = [];\n    this.gl = this.canvas.getContext(\"experimental-webgl\", opt.context || {\n      antialias: true,\n      depth: false\n    });\n    if (!this.gl) {\n      alert('failed to start webgl :(');\n    }\n    this.focus = -1;\n    this.setViewport();\n    if (opt.resize) {\n      window.addEventListener('resize', this.setViewport);\n    }\n    if (opt.clearColor) {\n      this.gl.clearColor(opt.clearColor[0], opt.clearColor[1], opt.clearColor[2], opt.clearColor[3]);\n    } else {\n      this.gl.clearColor(0, 0, 0, 1);\n    }\n    for (y = j = 0, ref = this.grid[1]; 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {\n      for (x = k = 0, ref1 = this.grid[0]; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {\n        this.pos.push({x, y});\n      }\n    }\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n  }\n\n  createBuffer(x, y, verts) {\n    var buffer, mx, my, sx, sy;\n    buffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(verts), this.gl.STATIC_DRAW);\n    mx = -this.grid[0] + 1 + x * 2;\n    my = this.grid[1] - 1 - y * 2;\n    buffer.u_move = {\n      origin: [mx, my],\n      state: [mx, my],\n      stage: [mx, my]\n    };\n    sx = 1 / this.grid[0];\n    sy = 1 / this.grid[1];\n    buffer.u_scale = {\n      origin: [sx, sy],\n      state: [sx, sy],\n      stage: [sx, sy]\n    };\n    return buffer;\n  }\n\n  setViewport() {\n    var j, len, ref, results, shader;\n    this.canvas.width = this.width = this.canvas.clientWidth;\n    this.canvas.height = this.height = this.canvas.clientHeight;\n    this.gl.viewport(0, 0, this.width, this.height);\n    ref = this.shaders;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      shader = ref[j];\n      results.push(shader.setUvBuffer(shader.index));\n    }\n    return results;\n  }\n\n  add(shader) {\n    shader.init(this, this.shaders.length);\n    this.shaders.push(shader);\n    return this;\n  }\n\n  clear() {\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n    return this;\n  }\n\n  draw(shader) {\n    var _u, i, j, len, ref, u, v_buffer;\n    if (!shader.gl) {\n      throw new Error('shader has not been added.');\n    }\n    i = i || 0;\n    v_buffer = shader.vert_buffer;\n    this.gl.useProgram(shader.program);\n    shader.updateUvBuffer();\n    if (this.focus >= 0) {\n      if (shader.index === this.focus) {\n        v_buffer.u_move.state[0] = v_buffer.u_move.state[1] = 0;\n        v_buffer.u_scale.state[0] = v_buffer.u_scale.state[1] = 1;\n      } else {\n        v_buffer.u_scale.state[0] = v_buffer.u_scale.state[1] = 0;\n      }\n    } else {\n      v_buffer.u_move.state[0] = v_buffer.u_move.origin[0];\n      v_buffer.u_move.state[1] = v_buffer.u_move.origin[1];\n      v_buffer.u_scale.state[0] = v_buffer.u_scale.origin[0];\n      v_buffer.u_scale.state[1] = v_buffer.u_scale.origin[1];\n    }\n    v_buffer.u_move.stage[0] += 0.25 * (v_buffer.u_move.state[0] - v_buffer.u_move.stage[0]);\n    v_buffer.u_move.stage[1] += 0.25 * (v_buffer.u_move.state[1] - v_buffer.u_move.stage[1]);\n    v_buffer.u_scale.stage[0] += 0.25 * (v_buffer.u_scale.state[0] - v_buffer.u_scale.stage[0]);\n    v_buffer.u_scale.stage[1] += 0.25 * (v_buffer.u_scale.state[1] - v_buffer.u_scale.stage[1]);\n    this.gl.uniform2f(shader.u_move, v_buffer.u_move.stage[0], v_buffer.u_move.stage[1]);\n    this.gl.uniform2f(shader.u_scale, v_buffer.u_scale.stage[0], v_buffer.u_scale.stage[1]);\n    ref = shader._uniforms;\n    for (j = 0, len = ref.length; j < len; j++) {\n      u = ref[j];\n      if (u.isArray) {\n        u.set(u.loc, shader.uniforms[u.name].val);\n      } else {\n        _u = shader.uniforms[u.name];\n        if (_u.val.length) {\n          u.set(u.loc, _u.val[0], _u.val[1], _u.val[2], _u.val[3]);\n        } else {\n          u.set(u.loc, _u.val);\n        }\n      }\n    }\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, v_buffer);\n    this.gl.vertexAttribPointer(shader.a_position, 2, this.gl.FLOAT, false, 0, 0);\n    this.gl.enableVertexAttribArray(shader.a_position);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shader.uv_buffer);\n    this.gl.vertexAttribPointer(shader.a_texture, 2, this.gl.FLOAT, false, 0, 0);\n    this.gl.enableVertexAttribArray(shader.a_texture);\n    if (shader.texture) {\n      this.gl.bindTexture(this.gl.TEXTURE_2D, shader.texture);\n      this.gl.uniform1i(shader.u_texture, 0);\n    }\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    return this;\n  }\n\n};\n\nvar Shader = class Shader {\n  constructor(opt) {\n    this.code = opt.code;\n    this.textureUrl = opt.textureUrl;\n    this.uniforms = opt.uniforms;\n    this._uniforms = [];\n    this.focus = false;\n    this.uv = opt.uv || [1.0, 1.0];\n  }\n\n  updateUvBuffer() {\n    if (this.box.focus === this.index && !this.focus) {\n      this.focus = true;\n      return this.setUvBuffer(this.index);\n    } else if (this.box.focus !== this.index && this.focus) {\n      this.focus = false;\n      return this.setUvBuffer(this.index);\n    }\n  }\n\n  setUvBuffer(i) {\n    var nh, nw, r_x, r_y;\n    // console.log @image_ratio_y,@image_ratio_x\n    if (this.focus) {\n      nw = this.box.width / this.uv[0];\n      nh = this.box.height / this.uv[1];\n    } else {\n      nw = this.box.width / this.uv[0] / this.box.grid[0];\n      nh = this.box.height / this.uv[1] / this.box.grid[1];\n    }\n    r_x = .5 - ((nw / nh) / 2);\n    r_y = .5 - (nh / nw) / 2;\n    if (r_x > 0) {\n      r_y = 0;\n    } else {\n      // r_x *= @image_ratio_x\n      r_x = 0;\n    }\n    // r_y *= @image_ratio_y\n    return this.uv_buffer = this.box.createBuffer(this.box.pos[i].x, this.box.pos[i].y, [r_x, 1 - r_y, r_x, r_y, 1 - r_x, 1 - r_y, 1 - r_x, 0 + r_y]);\n  }\n\n  setVertBuffer(i) {\n    return this.vert_buffer = this.box.createBuffer(this.box.pos[i].x, this.box.pos[i].y, [-1, -1, -1, 1, 1, -1, 1, 1]);\n  }\n\n  init(box, index) {\n    var image, key, ref, results, u, val;\n    this.box = box;\n    this.index = index;\n    this.setUvBuffer(this.index);\n    this.setVertBuffer(this.index);\n    this.gl = this.box.gl;\n    this.program = this.createProgram(default_vertex_shader, this.code);\n    this.a_position = this.gl.getAttribLocation(this.program, \"a_position\");\n    this.a_texture = this.gl.getAttribLocation(this.program, \"a_texture\");\n    this.u_move = this.gl.getUniformLocation(this.program, \"u_move\");\n    this.u_scale = this.gl.getUniformLocation(this.program, \"u_scale\");\n    this.u_texture = this.gl.getUniformLocation(this.program, \"u_texture\");\n    if (this.textureUrl) {\n      this.texture = this.gl.createTexture();\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\n      image = new Image();\n      image.src = this.textureUrl;\n      image.addEventListener('load', (e) => {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\n        return this.setUvBuffer(this.index);\n      });\n    }\n    ref = this.uniforms;\n    results = [];\n    for (key in ref) {\n      val = ref[key];\n      u = {\n        loc: this.gl.getUniformLocation(this.program, key),\n        set: this.gl[\"uniform\" + val.type].bind(this.gl),\n        name: key,\n        isArray: val.type.match(/v$/) != null\n      };\n      results.push(this._uniforms.push(u));\n    }\n    return results;\n  }\n\n  createProgram(vert, frag) {\n    var fs, prog, vs;\n    // make fragment shader\n    fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    this.gl.shaderSource(fs, frag);\n    this.gl.compileShader(fs);\n    if (!this.gl.getShaderParameter(fs, this.gl.COMPILE_STATUS)) {\n      throw new Error('FRAGMENT_COMPILE_' + this.gl.getShaderInfoLog(fs));\n    }\n    // make vertex shader\n    vs = this.gl.createShader(this.gl.VERTEX_SHADER);\n    this.gl.shaderSource(vs, vert);\n    this.gl.compileShader(vs);\n    if (!this.gl.getShaderParameter(vs, this.gl.COMPILE_STATUS)) {\n      throw new Error('VERTEX_COMPILE_' + this.gl.getShaderInfoLog(vs));\n    }\n    // make and use program\n    prog = this.gl.createProgram();\n    this.gl.attachShader(prog, fs);\n    this.gl.attachShader(prog, vs);\n    this.gl.linkProgram(prog);\n    if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {\n      throw new Error('SHADER_LINK_' + this.gl.getProgramInfoLog(prog));\n    }\n    return prog;\n  }\n\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports=opts=>\"attribute vec2 a_position;\\nattribute vec2 a_texture;\\nuniform vec2 u_move;\\nuniform vec2 u_scale;\\nvarying vec2 v_uv;\\nvoid main() {\\n\\tgl_Position = vec4((a_position + u_move) * u_scale, 0.0, 1.0);\\n\\tv_uv = a_texture;\\n}\\n\";\n\n/***/ })\n/******/ ]);\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/shader-box/shader-box.js\n// module id = 0\n// module chunks = 0 1","{Box,Shader} = require 'shader-box'\n\n\n\n\nwindow.box = new Box\n\tgrid: [1,1]\n\tcanvas: window.canvas\n\tresize: true\n\tcontext:\n\t\tantialias: false\n\t\tdepth: false\n\n\nflare = new Shader\n\tcode: require('./flare.glsl').default\n\tuniforms: \n\t\tiTime:\n\t\t\ttype:'1f'\n\t\t\tval:0\n\n\nbox.add(flare)\n\n\ntick = (t)->\n\trequestAnimationFrame(tick)\n\tflare.uniforms.iTime.val = t/2e3\n\tbox\n\t\t.clear()\n\t\t.draw(flare)\n\n\ntick(0)\n\n\n// WEBPACK FOOTER //\n// ./source/main.coffee","export default \"precision highp float;\\nuniform float iTime;\\nvarying vec2 v_uv;\\n\\n#define PI 3.14159265359\\n#define TWO_PI 6.28318530718\\n\\n\\nfloat random (in vec2 _st) { \\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.54531237);\\n}\\n\\nfloat noise (in vec2 _st) {\\n    vec2 i = floor(_st);\\n    vec2 f = fract(_st);\\n\\n    // Four corners in 2D of a tile\\n    float a = random(i);\\n    float b = random(i + vec2(1.0, 0.0));\\n    float c = random(i + vec2(0.0, 1.0));\\n    float d = random(i + vec2(1.0, 1.0));\\n\\n    vec2 u = f * f * (3. - 2.0 * f);\\n\\n    return mix(a, b, u.x) + \\n            (c - a)* u.y * (1. - u.x) + \\n            (d - b) * u.x * u.y;\\n}\\n\\n\\nfloat light(in vec2 pos,in float size,in float radius,in float inner_fade,in float outer_fade){\\n    float len = length(pos/size);\\n    return pow(clamp((1.0 - pow( clamp(len-radius,0.0,1.0) , 1.0/inner_fade)),0.0,1.0),1.0/outer_fade);\\n}\\n\\nfloat flare(in float angle,in float alpha,in float time){\\n    float t = time;\\n    float n = noise(vec2(t+angle+pow(alpha,0.5),t-angle+pow(alpha,0.5))*6.0);\\n    // float n = 0.5;\\n    \\n    float split = (10.0+sin(n*4.0+angle*20.0+alpha*4.0*n)*alpha*1.9);\\n\\n    float rotate = sin(t*2.0+angle*10.0+alpha*20.0 + n*1.5)+angle*2.5*(1.5+0.2*n);\\n    \\n    \\n    float g = pow((2.0+sin(split+n*2.5*alpha+rotate)*1.4)*(1.0+n*3.5),0.1+n*(1.2-0.6*alpha));\\n    \\n\\n    g *= pow((angle+PI)*(TWO_PI - angle - PI),0.45)*0.2; //fade out at pole \\n    g *= alpha * alpha * alpha;\\n    g += alpha + g * g;\\n    return g;\\n}\\n\\n\\n\\n\\n\\n\\n#define SIZE 1.\\n#define RADIUS 0.09\\n#define INNER_FADE .81\\n#define OUTER_FADE 0.02\\n#define SPEED 0.2\\n\\n#define BORDER 0.091\\n\\n\\nvoid main() {\\n    vec2 uv = -vec2(v_uv.x-0.5,v_uv.y-0.5);\\n    float f = 0.0;\\n    float f2 = 0.0;\\n    float t = iTime * SPEED;\\n    float alpha = light(uv,SIZE,RADIUS,INNER_FADE*1.5,OUTER_FADE*4.0);\\n    float angle = atan(uv.x,uv.y);\\n    float l = length(uv);\\n    if(l < BORDER){\\n        alpha = (1.0 - pow(((BORDER - l)*2.2/BORDER)*6.0,0.22)*0.68)+0.25;\\n        f = flare(angle,alpha*0.7,t)*1.8;\\n        f2 = flare(angle,alpha*1.3,((t+.5)*1.1))*0.5;\\n    }else if(alpha < 0.001){\\n        f = alpha;\\n    }else{\\n        f = flare(angle,alpha,t)*1.3;\\n    }\\n    gl_FragColor = vec4(vec3(f+f2*f2*f2,f*alpha+f2*f2*2.0,f*alpha*0.50+f2*1.6)*(.85),1.0);\\n}\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./source/flare.glsl\n// module id = 2\n// module chunks = 1"],"sourceRoot":""}